// automatically generated by Xtext
grammar ac.soton.xumlb.XUmlb with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://soton.ac.uk/models/eventb/classdiagrams/2020" as eclassdiagrams
import "http://emf.eventb.org/models/core/2014" as eventbcore
import "http://soton.ac.uk/models/eventb/statemachines/2014" as estatemachines
import "http://soton.ac.uk/models/eventb/diagrams/2020" as ediagrams
import "http://soton.ac.uk/models/eventb/coreextension/2014" as ecoreextension
import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore#//machine"as emachine

XUMLB returns ediagrams::UMLB:
	'UMLB'
	name= ID
	('elaborates' elaborates=[eventbcore::EventBNamedCommentedComponentElement|QualifiedName])? // this will be the target machine/context instead of annotate
	('refines' refines=[ediagrams::UMLB|QualifiedName])?
	( diagrams+= XDiagram* )	
;

XDiagram returns ediagrams::Diagram:
	Statemachine | Classdiagram
;                                                                                                                                                                                                     

/********************************************
 * Statemachine grammar
 ********************************************/
Statemachine returns estatemachines::Statemachine:
{estatemachines::Statemachine}
	'statemachine'
	name=ID '(' translation=TranslationKind ')'
	('refines' refines=[estatemachines::Statemachine|QualifiedName])?
	(
	   'instances' instances=[eventbcore::EventBNamedCommentedElement|QualifiedName]
	   'selfName' selfName=EString
	)?
	nodes += AbstractNode*
	transitions += Transition* 
	'end'
;

AbstractNode returns estatemachines::AbstractNode:
	State | Initial | Final | Any | Junction | Fork;


Transition returns estatemachines::Transition:
	{estatemachines::Transition}
	'transition'
		('elaborates' elaborates+=[emachine::Event|QualifiedName]+)?
		(extended?='extended')?
//		('refines' refines=[coreextension::EventBEventGroup|EString])?
        'source' source=[estatemachines::AbstractNode|QualifiedName]
		'target' target=[estatemachines::AbstractNode|QualifiedName]
		('any' parameters+=TypedParameter ( ',' parameters+=TypedParameter)* )?
		('where' guards+=Guard+)?
		('then' actions+=Action+)?
		('with' witnesses+=Witness+)?
		'end'
;

enum TranslationKind returns estatemachines::TranslationKind:
		MULTIVAR = 'variables' | SINGLEVAR = 'enumeration' | REFINEDVAR = 'REFINEDVAR';

TypedParameter returns ecoreextension::TypedParameter:
	name=ID ':' type=XType
;

XType returns ecore::EString:
	XComplexType ('×' XComplexType)*
;

XComplexType:
	'ℙ' '(' XType ')' | EVENT_B_BUILDIN_TYPE | ID
;

EVENT_B_BUILDIN_TYPE returns ecore::EString:
	'BOOL' | 
	'ℤ'
;
	
State returns estatemachines::State:
	{estatemachines::State}
	'state'
	name=EString
	('refines' refines=[estatemachines::State|QualifiedName])?
	('statemachines' 'begin' statemachines+=Statemachine ( statemachines+=Statemachine)* 'end' )?
	('invariants' invariants+=Invariant+ )?
	('entryActions' entryActions+=Action+ )?
	('exitActions' exitActions+=Action+ )?
;

Initial returns estatemachines::Initial:
	'initial' name=EString
;

Final returns estatemachines::Final:
	'final'	name=EString
;

Any returns estatemachines::Any:
	'any' name=EString
;

Junction returns estatemachines::Junction:
	'junction' name=EString
;

Fork returns estatemachines::Fork:
	'fork' name=EString
;

/*********************************************
 * Class Diagram Grammar
 ********************************************/
Classdiagram returns eclassdiagrams::Classdiagram:
	{eclassdiagrams::Classdiagram}
	'classdiagram'
	    name = ID
		('refines' refines=[eclassdiagrams::Classdiagram|QualifiedName])?
//		('classes' classes+=Class+)? 
		( classes+=Class*)
		( associations+=Association*)
	'end'
;

EventBSuperType returns eclassdiagrams::EventBSuperType:
	 Class | SubtypeGroup
;	

Class returns eclassdiagrams::Class:
	{eclassdiagrams::Class}
	'class' 
	    name = ID '(' dataKind = DataKind ')'
	    ('elaborates' elaborates=[eventbcore::EventBNamed|QualifiedName])?
		('selfName' selfName = EString)?
		('instances' instances=EString)?
//	    ('supertypes' supertypes+=[eclassdiagrams::Class|QualifiedName]+)?
        ('supertypes' supertypes+=[eclassdiagrams::EventBSuperType]+)?
		('refines' refines=[eclassdiagrams::Class|QualifiedName])?
		('statemachines' 'begin' statemachines+=Statemachine+ 'end')?
		(  classAttributes+=ClassAttribute* )
		(  constraints+=ClassConstraint*)
		(  methods+=ClassMethod*)
		('subtypeGroups'  subtypeGroups+=SubtypeGroup+)?
;
	
Association returns  eclassdiagrams::Association:
	{eclassdiagrams::Association}
	'association'
	    name = ID '(' dataKind = DataKind ')'
	    ('elaborates' elaborates=[eventbcore::EventBNamed|QualifiedName])?
	    (functional ?= 'functional')?
		(total ?= 'total')?
		(surjective ?= 'surjective')? 
		(injective ?= 'injective')?
		('initialValue' initialValue=EString)?
		'source' source=[eclassdiagrams::Class|QualifiedName]
		'target' target=[eclassdiagrams::Class|QualifiedName]
;
	
SubtypeGroup returns eclassdiagrams::SubtypeGroup:
	{eclassdiagrams::SubtypeGroup}
	'SubtypeGroup'
	    name = ID
		(cover?='cover')?
		(disjoint?='disjoint')?
//		('subtypes' subtypes += [eclassdiagrams::Class|QualifiedName]+)?
;

ClassAttribute returns eclassdiagrams::ClassAttribute:
	{eclassdiagrams::ClassAttribute}
	'attribute'
	     name = ID '(' dataKind = DataKind ')'
	    ('elaborates' elaborates=[eventbcore::EventBNamed|QualifiedName])?
	    (functional ?= 'functional')?
		(total ?= 'total')?
		(surjective ?= 'surjective')? 
		(injective ?= 'injective')?
		('initialValue' initialValue= EString)?
		'target' target=EString
;

ClassConstraint returns eclassdiagrams::ClassConstraint:
	{eclassdiagrams::ClassConstraint}
	'constraint'
	(theorem?='theorem')? name = ID //maybe XLabel instead of ID
	predicate = XFormula
	'component' component = [eventbcore::EventBNamedCommentedComponentElement|QualifiedName]
	//component is the context or machine it is added to, do we do it manually or assigned automatically
	// when generating.
;

ClassMethod returns eclassdiagrams::ClassMethod:
	{eclassdiagrams::ClassMethod}
	'method' // How to reference the event
		'kind' kind=MethodKind
		('elaborates' elaborates+=[emachine::Event|QualifiedName]+)?
		(extended?='extended')?
//		('refines' refines=[coreextension::EventBEventGroup|QualifiedName])? //probably not needed can be received from event
        ('any' parameters+=TypedParameter ( ',' parameters+=TypedParameter)* )?
		('where' guards+=Guard+)?
		('then' actions+=Action+)?
		('with' witnesses+=Witness+)?
		'end'
;

enum MethodKind returns eclassdiagrams::MethodKind:
	normal = 'normal' | constructor = 'constructor' | destructor = 'destructor'
;

enum DataKind returns ecoreextension::DataKind:
	SET = 'set' | CONSTANT = 'constant' | VARIABLE = 'variable'
;

/*********************************************
 * Generic grammar
 ********************************************/
EString returns ecore::EString:
	STRING | ID;

QualifiedName:
	ID('.'ID)?
;

terminal XLABEL returns ecore::EString:
	'@' !(':')+ ':'
;

XFormula returns ecore::EString:
	(
		EVENTB_IDENTIFIER_KEYWORD |
		EVENTB_PREDICATE_SYMBOLS |
		EVENTB_EXPRESSION_SYMBOLS |
		ID |
		INT
	)+ 
;

EVENTB_IDENTIFIER_KEYWORD returns ecore::EString:
	'BOOL' |
	'FALSE' |
	'TRUE' |
	'bool' |
	'card' |
	'dom' |
	'finite' |
	'id' |
	'inter' |
	'max' |
	'min' |
	'mod' |
	'pred' |
	'prj1' |
	'prj2' |
	'ran' |
	'succ' |
	'union' |
	'ℕ1' |
	'ℕ' |
	'ℙ1' |
	'ℙ' |
	'ℤ'
;

EVENTB_PREDICATE_SYMBOLS returns ecore::EString:
	'(' | // Predicate calculus symbols
	')' |
	'⇔' | 
	'⇒' |
	'∧' | '&' |
	'∨' |
	'¬' |
	'⊤' |
	'⊥' |
	'∀' | '!' |
	'∃' | '#' |
	',' |
	'·' | '.' |
	'=' | // Build predicates from expressions
	'≠' |
	'≤' |
	'<' |
	'≥' |
	'>' |
	'∈' | ':' | // Include this for Rodin keyboard
	'∉' | 
	'⊂' |
	'⊄' |
	'⊆' |
	'⊈' |
	'partition' // This is missing from the Rodin D7 deliverable
;

EVENTB_EXPRESSION_SYMBOLS returns ecore::EString:
	'↔' | // Symbols for building set of relations
	'' |
	'' |
	'' |
	'⇸' |
	'→' |
	'⤔' |
	'↣' |
	'⤀' |
	'↠' |
	'⤖' |
	'{' | // Symbols for manipulating sets
	'}' |
	'↦' |
	'∅' |
	'∩' |
	'∪' |
	'∖' |
	'×' |
	'[' | // Symbols for manipulating functions and relations
	']' |
	'' |
	'∘' |
	';' |
	'⊗' |
	'∥' |
	'∼' |
	'◁' |
	'⩤' |
	'▷' |
	'⩥' |
	'λ' | '%' // Symbols for quantified expressions
	'⋂' |
	'⋃' |
	'∣' |
	'‥' | // Symbols for arithmetic expressions
	'+' |
	'−' | '-' |
	'∗' | '*' |
	'÷' | '/' | 
	'^' |
	'\\' // Allowed for LaTeX combos
;

@Override 
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_'| 'i'..'\u00D6' | '\u00D8'..'ￜ') ('a'..'z'|'A'..'Z'|'_'| 'i'..'\u00D6' | '\u00D8'..'ￜ'|'0'..'9' | "'")*;

/*********************************************
 * machine related grammar
 ********************************************/
 Invariant returns emachine::Invariant:
	(theorem?='theorem')? name=XLABEL predicate=XFormula
;

Guard returns emachine::Guard:
	(theorem?='theorem')? name=XLABEL predicate= XFormula
;

Action returns emachine::Action:
	name=XLABEL action=XFormula
;

Witness returns emachine::Witness:
	name=XLABEL	predicate=XFormula
;